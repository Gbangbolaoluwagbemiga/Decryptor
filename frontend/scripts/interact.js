
const { STACKS_MAINNET } = require('@stacks/network');
const { 
  makeSTXTokenTransfer, 
  broadcastTransaction, 
  makeContractCall, 
  uintCV, 
  stringAsciiCV, 
  AnchorMode,
  PostConditionMode,
  getAddressFromPrivateKey
} = require('@stacks/transactions');
const { generateWallet } = require('@stacks/wallet-sdk');
const { generateMnemonic } = require('bip39');

// Configuration
const DEPLOYER_MNEMONIC = "ship protect endorse arrow because path meat immune quote drink fluid state mask burger divert upset arena body column all tray sing viable arctic";
const CONTRACT_ADDRESS = "SP2QNSNKR3NRDWNTX0Q7R4T8WGBJ8RE8RA516AKZP";
const CONTRACT_NAME = "crowdfunding-v2";
const FUND_AMOUNT = 10000; // 0.01 STX (in microSTX)
const NUM_WALLETS = 12;

const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

async function main() {
  const network = STACKS_MAINNET;

  // 1. Setup Deployer
  console.log("Setting up deployer...");
  const deployerWallet = await generateWallet({ secretKey: DEPLOYER_MNEMONIC, password: '' });
  const deployerAccount = deployerWallet.accounts[0];
  const deployerKey = deployerAccount.stxPrivateKey;
  // Use default (Mainnet) for address derivation
  const deployerAddress = getAddressFromPrivateKey(deployerKey);
  
  console.log(`Deployer Address: ${deployerAddress}`);

  // 2. Generate 12 Random Wallets
  console.log(`Generating ${NUM_WALLETS} random wallets...`);
  const wallets = [];
  for (let i = 0; i < NUM_WALLETS; i++) {
    const mnemonic = generateMnemonic();
    const wallet = await generateWallet({ secretKey: mnemonic, password: '' });
    const account = wallet.accounts[0];
    const key = account.stxPrivateKey;
    const address = getAddressFromPrivateKey(key);
    
    wallets.push({
      address: address,
      key: key,
      mnemonic: mnemonic
    });
    console.log(`  Wallet ${i+1}: ${address}`);
  }

  // 3. Fund Wallets
  console.log("\nFunding wallets...");
  // Get current nonce for deployer
  const nonceUrl = `${network.client.baseUrl}/v2/accounts/${deployerAddress}?proof=0`;
  try {
      const nonceRes = await fetch(nonceUrl);
      if (!nonceRes.ok) throw new Error(`Fetch failed: ${nonceRes.statusText}`);
      const nonceData = await nonceRes.json();
      let nonce = BigInt(nonceData.nonce);
      
      console.log(`Starting nonce: ${nonce}`);

      for (const w of wallets) {
        await delay(1000); // Rate limit protection
        const txOptions = {
          recipient: w.address,
          amount: FUND_AMOUNT,
          senderKey: deployerKey,
          network,
          nonce: nonce,
          anchorMode: AnchorMode.Any,
        };
        
        try {
            const transaction = await makeSTXTokenTransfer(txOptions);
            // Fix: Pass object with named properties
            const broadcastResponse = await broadcastTransaction({ transaction, network });
            
            if (broadcastResponse.error) {
                 console.error(`Error funding ${w.address}:`, broadcastResponse.error);
                 // Retry once if rate limited or other error?
                 if (broadcastResponse.reason === 'ConflictingNonceInMempool') {
                     nonce++; // Should have been incremented, maybe try again?
                 }
            } else {
                console.log(`Funded ${w.address}: ${broadcastResponse.txid} (Nonce: ${nonce})`);
                nonce++;
            }
        } catch (e) {
            console.error(`Failed to fund ${w.address}:`, e.message);
        }
      }
  } catch (e) {
      console.error("Failed to fetch nonce or fund:", e);
      return; // Stop if funding fails
  }

  // 4. Interact
  console.log("\nInteracting (Note: Transactions might be pending until funding confirms)...");
  
  // Define possible interactions
  const interactions = [
    // Create Campaign
    async (wallet, n) => {
        const txOptions = {
            contractAddress: CONTRACT_ADDRESS,
            contractName: CONTRACT_NAME,
            functionName: 'create-campaign',
            functionArgs: [
                stringAsciiCV(`Campaign ${wallet.address.slice(0,5)}`),
                stringAsciiCV("Generated by interaction script"),
                stringAsciiCV("Tech"),
                uintCV(500),
                uintCV(10000)
            ],
            senderKey: wallet.key,
            validateWithAbi: true,
            network,
            anchorMode: AnchorMode.Any,
            postConditionMode: PostConditionMode.Allow,
            nonce: n
        };
        return makeContractCall(txOptions);
    },
    // Pledge to Campaign 1
    async (wallet, n) => {
        const txOptions = {
            contractAddress: CONTRACT_ADDRESS,
            contractName: CONTRACT_NAME,
            functionName: 'pledge',
            functionArgs: [
                uintCV(1),
                uintCV(1)
            ],
            senderKey: wallet.key,
            validateWithAbi: true,
            network,
            anchorMode: AnchorMode.Any,
            postConditionMode: PostConditionMode.Allow,
            nonce: n
        };
        return makeContractCall(txOptions);
    },
     // Cancel Campaign
    async (wallet, n) => {
         const txOptions = {
            contractAddress: CONTRACT_ADDRESS,
            contractName: CONTRACT_NAME,
            functionName: 'cancel-campaign',
            functionArgs: [
                uintCV(1)
            ],
            senderKey: wallet.key,
            validateWithAbi: true,
            network,
            anchorMode: AnchorMode.Any,
            postConditionMode: PostConditionMode.Allow,
            nonce: n
        };
        return makeContractCall(txOptions);
    }
  ];

  for (const w of wallets) {
    // Pick 2 random interactions
    const idx1 = Math.floor(Math.random() * interactions.length);
    const idx2 = Math.floor(Math.random() * interactions.length);
    
    // Nonce starts at 0 for new wallets
    let wNonce = 0n;

    // Tx 1
    await delay(1000);
    try {
        const tx1 = await interactions[idx1](w, wNonce);
        const res1 = await broadcastTransaction({ transaction: tx1, network });
        
        if(res1.error) {
            console.error(`[${w.address}] Interaction 1 Error:`, res1.error);
        } else {
            console.log(`[${w.address}] Interaction 1: ${res1.txid}`);
            wNonce++;
        }
    } catch (e) {
        console.error(`[${w.address}] Interaction 1 Failed: ${e.message}`);
    }

    // Tx 2
    await delay(1000);
    try {
        const tx2 = await interactions[idx2](w, wNonce);
        const res2 = await broadcastTransaction({ transaction: tx2, network });
        
        if(res2.error) {
            console.error(`[${w.address}] Interaction 2 Error:`, res2.error);
        } else {
             console.log(`[${w.address}] Interaction 2: ${res2.txid}`);
             wNonce++;
        }
    } catch (e) {
        console.error(`[${w.address}] Interaction 2 Failed: ${e.message}`);
    }
  }
}

main().catch(console.error);
